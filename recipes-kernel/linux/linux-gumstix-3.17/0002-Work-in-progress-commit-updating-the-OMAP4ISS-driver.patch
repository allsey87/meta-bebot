From 136494bb51a7bca294b894d2e9e81a2cdc56af8d Mon Sep 17 00:00:00 2001
From: Michael Allwright <allsey87@gmail.com>
Date: Tue, 17 Mar 2015 16:25:03 +0100
Subject: [PATCH 2/2] Work in progress commit - updating the OMAP4ISS driver to
 work with the device tree framework

---
 drivers/staging/media/omap4iss/iss.c | 286 ++++++++++++++++++++++-------------
 drivers/staging/media/omap4iss/iss.h |  21 +++
 include/media/omap4iss.h             |   7 +-
 3 files changed, 199 insertions(+), 115 deletions(-)

diff --git a/drivers/staging/media/omap4iss/iss.c b/drivers/staging/media/omap4iss/iss.c
index d548371..be9f8a2 100644
--- a/drivers/staging/media/omap4iss/iss.c
+++ b/drivers/staging/media/omap4iss/iss.c
@@ -14,7 +14,9 @@
 #include <linux/clk.h>
 #include <linux/delay.h>
 #include <linux/device.h>
+#include <linux/of_device.h>
 #include <linux/dma-mapping.h>
+#include <linux/dma-contiguous.h>
 #include <linux/i2c.h>
 #include <linux/interrupt.h>
 #include <linux/module.h>
@@ -27,6 +29,10 @@
 #include <media/v4l2-device.h>
 #include <media/v4l2-ctrls.h>
 
+#include <../arch/arm/mach-omap2/omap-pm.h>
+
+#include <linux/pm_runtime.h>
+
 #include "iss.h"
 #include "iss_regs.h"
 
@@ -50,6 +56,56 @@ static void iss_print_status(struct iss_device *iss)
 	dev_dbg(iss->dev, "-----------------------------------------------\n");
 }
 
+////////////////////// WORK IN PROGRESS
+
+static void iss_set_constraints(struct iss_device *iss, bool enable)
+{
+	if (!iss)
+		return;
+
+	/* FIXME: Look for something more precise as a good throughtput limit */
+	omap_pm_set_min_bus_tput(iss->dev, OCP_INITIATOR_AGENT,
+				 enable ? 800000 : -1);
+}
+
+static struct iss_v4l2_subdevs_group iss_subdevs[] = {
+	{
+		.driver = "ov5640",
+		.interface = ISS_INTERFACE_CSI2A_PHY1,
+		.bus = {
+			.csi2 = {
+				.lanecfg = {
+					.clk = {
+						.pol = 0,
+						.pos = 1,
+					},
+					.data[0] = {
+						.pol = 0,
+						.pos = 2,
+					},
+				},
+			}, 
+		},
+	},
+	{ },
+};
+
+
+static struct iss_platform_data iss_devtype = {
+	.subdevs = iss_subdevs,
+	.set_constraints = iss_set_constraints,
+};
+
+static struct of_device_id iss_dt_ids[] = {
+	{
+		.compatible = "ti,omap4-iss",
+		.data = &iss_devtype,
+	}, { }
+};
+MODULE_DEVICE_TABLE(of, iss_dt_ids);
+
+////////////////////// WORK IN PROGRESS END
+
 /*
  * omap4iss_flush - Post pending L3 bus writes by doing a register readback
  * @iss: OMAP4 ISS device
@@ -1005,9 +1061,9 @@ static void iss_disable_clocks(struct iss_device *iss)
 
 static int iss_get_clocks(struct iss_device *iss)
 {
-	iss->iss_fck = devm_clk_get(iss->dev, "iss_fck");
+	iss->iss_fck = devm_clk_get(iss->dev, "ducati_clk_mux_ck");
 	if (IS_ERR(iss->iss_fck)) {
-		dev_err(iss->dev, "Unable to get iss_fck clock info\n");
+		dev_err(iss->dev, "Unable to get ducati_clk_mux_ck clock info\n");
 		return PTR_ERR(iss->iss_fck);
 	}
 
@@ -1088,7 +1144,7 @@ static int iss_map_mem_resource(struct platform_device *pdev,
 				enum iss_mem_resources res)
 {
 	struct resource *mem;
-
+	
 	mem = platform_get_resource(pdev, IORESOURCE_MEM, res);
 
 	iss->regs[res] = devm_ioremap_resource(iss->dev, mem);
@@ -1109,59 +1165,78 @@ static void iss_unregister_entities(struct iss_device *iss)
 }
 
 /*
- * iss_register_subdev_group - Register a group of subdevices
- * @iss: OMAP4 ISS device
- * @board_info: I2C subdevs board information array
- *
- * Register all I2C subdevices in the board_info array. The array must be
- * terminated by a NULL entry, and the first entry must be the sensor.
- *
- * Return a pointer to the sensor media entity if it has been successfully
- * registered, or NULL otherwise.
+ * iss_subdev_notifier_bound - TODO
  */
-static struct v4l2_subdev *
-iss_register_subdev_group(struct iss_device *iss,
-		     struct iss_subdev_i2c_board_info *board_info)
-{
-	struct v4l2_subdev *sensor = NULL;
-	unsigned int first;
+static int iss_subdev_notifier_bound(struct v4l2_async_notifier *notifier,
+				     struct v4l2_subdev *sensor,
+				     struct v4l2_async_subdev *asd) {
 
-	if (board_info->board_info == NULL)
-		return NULL;
+	struct media_entity *input;
+	struct iss_device *iss;
+	unsigned int flags;
+	unsigned int pad;
+	int ret;
 
-	for (first = 1; board_info->board_info; ++board_info, first = 0) {
-		struct v4l2_subdev *subdev;
-		struct i2c_adapter *adapter;
-
-		adapter = i2c_get_adapter(board_info->i2c_adapter_id);
-		if (adapter == NULL) {
-			dev_err(iss->dev,
-				"%s: Unable to get I2C adapter %d for device %s\n",
-				__func__, board_info->i2c_adapter_id,
-				board_info->board_info->type);
-			continue;
-		}
+	iss = container_of(notifier, struct iss_device, subdev_notifier);
 
-		subdev = v4l2_i2c_new_subdev_board(&iss->v4l2_dev, adapter,
-				board_info->board_info, NULL);
-		if (subdev == NULL) {
-			dev_err(iss->dev, "%s: Unable to register subdev %s\n",
-				__func__, board_info->board_info->type);
-			continue;
-		}
+	v4l2_info(&iss->v4l2_dev, "%s: binding to sensor %s\n", __func__, sensor->name);
+
+	/* TODO: get info from device table */
+	input = &iss->csi2a.subdev.entity;
+	pad = CSI2_PAD_SINK;
+	flags = MEDIA_LNK_FL_IMMUTABLE
+		| MEDIA_LNK_FL_ENABLED;
 
-		if (first)
-			sensor = subdev;
+	/*
+	switch (subdevs->interface) {
+	case ISS_INTERFACE_CSI2A_PHY1:
+		input = &iss->csi2a.subdev.entity;
+		pad = CSI2_PAD_SINK;
+		flags = MEDIA_LNK_FL_IMMUTABLE
+			| MEDIA_LNK_FL_ENABLED;
+		break;
+		
+	case ISS_INTERFACE_CSI2B_PHY2:
+		input = &iss->csi2b.subdev.entity;
+		pad = CSI2_PAD_SINK;
+		flags = MEDIA_LNK_FL_IMMUTABLE
+			| MEDIA_LNK_FL_ENABLED;
+			break;
+			
+	default:
+		dev_err(iss->dev, "%s: invalid interface type %u\n",
+			__func__, subdevs->interface);
+		ret = -EINVAL;
+		goto done;
+	}
+	*/
+	v4l2_info(&iss->v4l2_dev, "Creating link");
+	ret = media_entity_create_link(&sensor->entity, 0, input, pad, flags);
+
+	if(ret < 0) {
+		v4l2_info(&iss->v4l2_dev, "Creating link failed!");
 	}
+	return ret;
+}
+
+static int iss_subdev_notifier_complete(struct v4l2_async_notifier *notifier) {
+	int ret;
+	struct iss_device *iss;
+	
+	iss = container_of(notifier, struct iss_device, subdev_notifier);
+	v4l2_info(&iss->v4l2_dev, "%s: registering subnodes", __func__);
+	ret = v4l2_device_register_subdev_nodes(&iss->v4l2_dev);
+	if(ret < 0)
+		v4l2_info(&iss->v4l2_dev, "%s: registering subnodes failed", __func__);
 
-	return sensor;
+	return ret;
 }
 
 static int iss_register_entities(struct iss_device *iss)
 {
 	struct iss_platform_data *pdata = iss->pdata;
 	struct iss_v4l2_subdevs_group *subdevs;
-	int ret;
+	int ret, i;
 
 	iss->media_dev.dev = iss->dev;
 	strlcpy(iss->media_dev.model, "TI OMAP4 ISS",
@@ -1187,71 +1262,32 @@ static int iss_register_entities(struct iss_device *iss)
 	ret = omap4iss_csi2_register_entities(&iss->csi2a, &iss->v4l2_dev);
 	if (ret < 0)
 		goto done;
-
 	ret = omap4iss_csi2_register_entities(&iss->csi2b, &iss->v4l2_dev);
 	if (ret < 0)
 		goto done;
-
 	ret = omap4iss_ipipeif_register_entities(&iss->ipipeif, &iss->v4l2_dev);
 	if (ret < 0)
 		goto done;
-
 	ret = omap4iss_ipipe_register_entities(&iss->ipipe, &iss->v4l2_dev);
 	if (ret < 0)
 		goto done;
-
 	ret = omap4iss_resizer_register_entities(&iss->resizer, &iss->v4l2_dev);
 	if (ret < 0)
 		goto done;
 
-	/* Register external entities */
-	for (subdevs = pdata->subdevs; subdevs && subdevs->subdevs; ++subdevs) {
-		struct v4l2_subdev *sensor;
-		struct media_entity *input;
-		unsigned int flags;
-		unsigned int pad;
-
-		sensor = iss_register_subdev_group(iss, subdevs->subdevs);
-		if (sensor == NULL)
-			continue;
-
-		sensor->host_priv = subdevs;
-
-		/* Connect the sensor to the correct interface module.
-		 * CSI2a receiver through CSIPHY1, or
-		 * CSI2b receiver through CSIPHY2
-		 */
-		switch (subdevs->interface) {
-		case ISS_INTERFACE_CSI2A_PHY1:
-			input = &iss->csi2a.subdev.entity;
-			pad = CSI2_PAD_SINK;
-			flags = MEDIA_LNK_FL_IMMUTABLE
-			      | MEDIA_LNK_FL_ENABLED;
-			break;
-
-		case ISS_INTERFACE_CSI2B_PHY2:
-			input = &iss->csi2b.subdev.entity;
-			pad = CSI2_PAD_SINK;
-			flags = MEDIA_LNK_FL_IMMUTABLE
-			      | MEDIA_LNK_FL_ENABLED;
-			break;
-
-		default:
-			dev_err(iss->dev, "%s: invalid interface type %u\n",
-				__func__, subdevs->interface);
-			ret = -EINVAL;
-			goto done;
-		}
-
-		ret = media_entity_create_link(&sensor->entity, 0, input, pad,
-					       flags);
-		if (ret < 0)
-			goto done;
+	/* Set up an asynchronous notify to register external entities */
+	for(i = 0; i < ISS_MAX_SENSORS; i++) {
+		iss->async_subdevs[i] = &iss->sensors[i].asd;
 	}
 
-	ret = v4l2_device_register_subdev_nodes(&iss->v4l2_dev);
+	iss->subdev_notifier.num_subdevs = iss->num_sensors;
+	iss->subdev_notifier.subdevs = iss->async_subdevs;
+	iss->subdev_notifier.bound = iss_subdev_notifier_bound;
+	iss->subdev_notifier.complete = iss_subdev_notifier_complete;
 
-done:
+	ret = v4l2_async_notifier_register(&iss->v4l2_dev,
+					   &iss->subdev_notifier);
+ done:
 	if (ret < 0)
 		iss_unregister_entities(iss);
 
@@ -1348,14 +1384,31 @@ error_csiphy:
 
 static int iss_probe(struct platform_device *pdev)
 {
-	struct iss_platform_data *pdata = pdev->dev.platform_data;
+	struct device_node *interface = NULL;
+	struct device_node *endpoint = NULL;
+	struct device_node *remote_endpoint = NULL;
+
 	struct iss_device *iss;
 	unsigned int i;
 	int ret;
+	int r;
 
-	if (pdata == NULL)
+	const struct of_device_id *of_id = 
+		of_match_device(iss_dt_ids, &pdev->dev);
+
+	if (of_id == NULL)
 		return -EINVAL;
 
+	pm_runtime_enable(&pdev->dev);
+	r = pm_runtime_get_sync(&pdev->dev);
+
+#ifdef CONFIG_CMA
+	/* Create private 32MiB contiguous memory area for omap4iss device */
+	/* Can not be done using the device tree in 3.17 */
+	//dma_declare_contiguous(&pdev->dev, 32*SZ_1M, 0, 0);
+#endif
+	// END OF CODE FROM OMAP4 CAMERA INIT
+
 	iss = devm_kzalloc(&pdev->dev, sizeof(*iss), GFP_KERNEL);
 	if (!iss) {
 		dev_err(&pdev->dev, "Could not allocate memory\n");
@@ -1365,12 +1418,38 @@ static int iss_probe(struct platform_device *pdev)
 	mutex_init(&iss->iss_mutex);
 
 	iss->dev = &pdev->dev;
-	iss->pdata = pdata;
+	iss->num_sensors = 0;
+	iss->pdata = &iss_devtype;
 
 	iss->raw_dmamask = DMA_BIT_MASK(32);
 	iss->dev->dma_mask = &iss->raw_dmamask;
 	iss->dev->coherent_dma_mask = DMA_BIT_MASK(32);
 
+	/* Parse and queue the remote end points */
+	interface = of_find_node_by_name(pdev->dev.of_node, "csi2");
+
+	if(interface != NULL) {
+		for_each_child_of_node(interface, endpoint) {
+			if(!strcmp(endpoint->name, "endpoint")) {
+				remote_endpoint = of_parse_phandle(endpoint, "remote-endpoint", 0);
+				if(iss->num_sensors < ISS_MAX_SENSORS && 
+				   remote_endpoint != NULL) {
+					dev_err(&pdev->dev, 
+						"setting up async match for %s\n", 
+						remote_endpoint->parent->parent->name,
+						remote_endpoint->parent->name,
+						remote_endpoint->name);
+
+					iss->sensors[iss->num_sensors].asd.match_type =
+						V4L2_ASYNC_MATCH_OF;
+					iss->sensors[iss->num_sensors].asd.match.of.node = 
+						remote_endpoint->parent->parent;
+					iss->num_sensors++;
+				}
+			}
+		}
+	}
+
 	platform_set_drvdata(pdev, iss);
 
 	/* Clocks */
@@ -1407,14 +1486,10 @@ static int iss_probe(struct platform_device *pdev)
 	ret = omap4iss_subclk_enable(iss, OMAP4_ISS_SUBCLK_ISP);
 	if (ret < 0)
 		goto error_iss;
-
 	ret = iss_isp_reset(iss);
 	if (ret < 0)
 		goto error_iss;
 
-	dev_info(iss->dev, "ISP Revision %08x found\n",
-		 iss_reg_read(iss, OMAP4_ISS_MEM_ISP_SYS1, ISP5_REVISION));
-
 	/* Interrupt */
 	iss->irq_num = platform_get_irq(pdev, 0);
 	if (iss->irq_num <= 0) {
@@ -1422,7 +1497,6 @@ static int iss_probe(struct platform_device *pdev)
 		ret = -ENODEV;
 		goto error_iss;
 	}
-
 	if (devm_request_irq(iss->dev, iss->irq_num, iss_isr, IRQF_SHARED,
 			     "OMAP4 ISS", iss)) {
 		dev_err(iss->dev, "Unable to request IRQ\n");
@@ -1465,22 +1539,16 @@ static int iss_remove(struct platform_device *pdev)
 	return 0;
 }
 
-static struct platform_device_id omap4iss_id_table[] = {
-	{ "omap4iss", 0 },
-	{ },
-};
-MODULE_DEVICE_TABLE(platform, omap4iss_id_table);
-
 static struct platform_driver iss_driver = {
 	.probe		= iss_probe,
 	.remove		= iss_remove,
-	.id_table	= omap4iss_id_table,
 	.driver = {
-		.owner	= THIS_MODULE,
-		.name	= "omap4iss",
+		.name	= "omap4-iss",
+		.of_match_table = iss_dt_ids,
 	},
 };
 
+
 module_platform_driver(iss_driver);
 
 MODULE_DESCRIPTION("TI OMAP4 ISS driver");
diff --git a/drivers/staging/media/omap4iss/iss.h b/drivers/staging/media/omap4iss/iss.h
index 734cfee..d30f41b 100644
--- a/drivers/staging/media/omap4iss/iss.h
+++ b/drivers/staging/media/omap4iss/iss.h
@@ -15,6 +15,7 @@
 #define _OMAP4_ISS_H_
 
 #include <media/v4l2-device.h>
+#include <media/v4l2-of.h>
 #include <linux/device.h>
 #include <linux/io.h>
 #include <linux/platform_device.h>
@@ -29,6 +30,8 @@
 #include "iss_ipipe.h"
 #include "iss_resizer.h"
 
+#define ISS_MAX_SENSORS 2
+
 #define to_iss_device(ptr_module)				\
 	container_of(ptr_module, struct iss_device, ptr_module)
 #define to_device(ptr_module)						\
@@ -78,6 +81,14 @@ struct iss_reg {
 };
 
 /*
+ * struct iss_subdev - Structure for ISS subdevs.
+ */
+struct iss_subdev {
+	struct v4l2_async_subdev asd;
+	struct v4l2_of_endpoint endpoint;
+};
+
+/*
  * struct iss_device - ISS device structure.
  * @crashed: Bitmask of crashed entities (indexed by entity ID)
  */
@@ -88,6 +99,8 @@ struct iss_device {
 	u32 revision;
 
 	/* platform HW resources */
+	struct iss_subdev sensors[ISS_MAX_SENSORS];
+
 	struct iss_platform_data *pdata;
 	unsigned int irq_num;
 
@@ -101,6 +114,14 @@ struct iss_device {
 	int has_context;
 	int ref_count;
 
+	/* notifier for registering the subdevs */
+	struct v4l2_async_notifier subdev_notifier;
+	struct v4l2_async_subdev *async_subdevs[ISS_MAX_SENSORS];
+	unsigned int num_sensors;
+
+	/* */
+
+
 	struct clk *iss_fck;
 	struct clk *iss_ctrlclk;
 
diff --git a/include/media/omap4iss.h b/include/media/omap4iss.h
index 0d7620d..8045cb2 100644
--- a/include/media/omap4iss.h
+++ b/include/media/omap4iss.h
@@ -44,13 +44,8 @@ struct iss_csi2_platform_data {
 	struct iss_csiphy_lanes_cfg lanecfg;
 };
 
-struct iss_subdev_i2c_board_info {
-	struct i2c_board_info *board_info;
-	int i2c_adapter_id;
-};
-
 struct iss_v4l2_subdevs_group {
-	struct iss_subdev_i2c_board_info *subdevs;
+	char *driver;
 	enum iss_interface_type interface;
 	union {
 		struct iss_csi2_platform_data csi2;
-- 
1.9.1

